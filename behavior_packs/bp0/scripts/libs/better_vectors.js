function sqr(t){return t*t}export class bVector2{constructor(t,s){this.x=0,this.y=0,void 0!==t&&(this.x=t),void 0!==s&&(this.y=s)}set(t,s){void 0===t||void 0===s?console.error("No value has been passed to the bVector2 set function"):(this.x=t,this.y=s)}add(t){void 0===t?console.error("No vector has been passed to the bVector2 add function"):(this.x+=t.x,this.y+=t.y)}static add(t,s){if(void 0===t||void 0===s)return console.error("No vector has been passed to the bVector2 add function"),null;{let e=t.copy();return e.x+=s.x,e.y+=s.y,e}}subtract(t){void 0===t?console.error("No vector has been passed to the bVector2 subtract function"):(this.x-=t.x,this.y-=t.y)}static subtract(t,s){if(void 0===t||void 0===s)return console.error("No vector has been passed to the bVector2 subtract function"),null;{let e=t.copy();return e.x-=s.x,e.y-=s.y,e}}multiply(t){void 0===t&&(t=1),this.x*=t,this.y*=t}static multiply(t,s){if(void 0===t)return console.error("No vector has been passed to the bVector2 multiply function"),null;{let e=t.copy();return void 0===s&&(s=1),e.x*=s,e.y*=s,t}}divide(t){void 0===t&&(t=1),t=1/t,this.multiply(t)}static divide(t,s){if(void 0===t)return console.error("No vector has been passed to the bVector2 divide function"),null;{let e=t.copy();return void 0===s&&(s=1),e.x/=s,e.y/=s,t}}angle(){return 180*Math.atan(this.y/this.x)/Math.PI}rotate(t){let s=this.x,e=this.y;this.x=Math.cos(t)*s-Math.sin(t)*e,this.y=Math.sin(t)*s+Math.cos(t)*e}magnitude(){return Math.sqrt(sqr(this.x)+sqr(this.y))}magnitudeSqr(){return sqr(this.x)+sqr(this.y)}setMagnitude(t){let s=t/Math.sqrt(sqr(this.x)+sqr(this.y));this.x*=s,this.y*=s}limit(t,s){let e=t,r=null;s&&(e=s,r=t),r&&this.magnitude()<r&&this.setMagnitude(r),this.magnitude()>e&&this.setMagnitude(e)}copy(){return new bVector2(this.x,this.y)}normalize(){let t=new bVector2(this.x,this.y),s=Math.sqrt(sqr(t.x)+sqr(t.y));t.x=t.x/s,t.y=t.y/s,this.previousX=this.x,this.previousY=this.y,this.x=t.x,this.y=t.y}distance(t){if(void 0!==t)return Math.sqrt(sqr(this.x-t.x)+sqr(this.y-t.y));console.error("You need to pass another bVector2 instance to the bVector2 distance method")}static distance(t,s){if(void 0!==s)return Math.sqrt(sqr(t.x-s.x)+sqr(t.y-s.y));console.error("bVector2 distance method expects two instances of bVector2")}lerp(t,s){void 0===t||void 0===s?console.error("Invalid arguments for the bVector2 lerp method"):(this.x=(1-s)*this.x+s*t.x,this.y=(1-s)*this.y+s*t.y)}static lerp(t,s,e){if(void 0===t||void 0===s||void 0===e)return console.error("Invalid arguments for the bVector2 lerp method"),null;{let r=t.copy();return r.x=(1-e)*r.x+e*s.x,r.y=(1-e)*r.y+e*s.y,r}}clamp(t,s,e,r){this.x>=s?this.x=s:this.x<=t&&(this.x=t),this.y>=r?this.y=r:this.y<=e&&(this.y=e)}static fromVector2(t){return new bVector2(t.x,t.y)}toVector2(){return{x:this.x,y:this.y}}stringify(){return`x: ${this.x}, y: ${this.y}`}static fromAngle(t){return new bVector2(cos(t),sin(t))}static random(){let t=Math.random();Math.random();return new bVector2(t,y)}angleOffset(t){return 180*Math.atan2(t.y*this.x-t.x*this.y,t.x*this.x+t.y*this.y)/Math.PI}static angleOffset(t,s){return 180*Math.atan2(s.y*t.x-s.x*t.y,s.x*t.x+s.y*t.y)/Math.PI}crossProduct(t){return this.x*t.y-t.x*this.y}static crossProduct(t,s){return void 0===t||void 0===s?(console.error("No valid arguments provided to the bVector2 crossProduct method"),null):t.x*s.y-s.x*t.y}dotProduct(t){return this.x*t.x+this.y*t.y}static dotProduct(t,s){return void 0===t||void 0===s?(console.error("No valid arguments provided to the bVector2 dotProduct method"),null):t.x*s.x+t.y*s.y}}export class bVector3{constructor(t,s,e){this.x=0,this.y=0,this.z=0,void 0!==t&&(this.x=t),void 0!==s&&(this.y=s),void 0!==e&&(this.z=e)}set(t,s,e){void 0===t||void 0===s||void 0===e?console.error("No value has been passed to the bVector3 set function"):(this.x=t,this.y=s,this.z=e)}add(t){void 0===t?console.error("No vector has been passed to the bVector3 add function"):(this.x+=t.x,this.y+=t.y,this.z+=t.z)}static add(t,s){if(void 0===t||void 0===s)return console.error("No vector has been passed to the bVector3 add function"),null;{let e=t.copy();return e.x+=s.x,e.y+=s.y,e.z+=s.z,e}}subtract(t){void 0===t?console.error("No vector has been passed to the bVector3 subtract function"):(this.x-=t.x,this.y-=t.y,this.z-=t.z)}static subtract(t,s){if(void 0===t||void 0===s)return console.error("No vector has been passed to the bVector3 subtract function"),null;{let e=t.copy();return e.x-=s.x,e.y-=s.y,e.z-=s.z,e}}multiply(t){void 0===t&&(t=1),this.x*=t,this.y*=t,this.z*=t}static multiply(t,s){if(void 0===t)return console.error("No vector has been passed to the bVector3 multiply function"),null;{let e=t.copy();return void 0===s&&(s=1),e.x*=s,e.y*=s,e.z*=s,e}}divide(t){void 0===t&&(t=1),t=1/t,this.multiply(t)}static divide(t,s){if(void 0===t)return console.error("No vector has been passed to the bVector3 divide function"),null;{let e=t.copy();return void 0===s&&(s=1),e.x/=s,e.y/=s,e.z/=s,e}}angles(){return{theta:-180*Math.atan2(this.x,this.z)/Math.PI,phi:180*Math.atan(this.y/Math.sqrt(sqr(this.x)+sqr(this.z)))/Math.PI}}rotateX(t){this.x;let s=this.y,e=this.z;this.y=cos(t)*s-sin(t)*e,this.z=sin(t)*s+cos(t)*e}rotateY(t){let s=this.x,e=(this.y,this.z);this.x=cos(t)*s+sin(t)*e,this.z=sin(t)*-s+cos(t)*e}rotateZ(t){let s=this.x,e=this.y;this.z;this.x=cos(t)*s-sin(t)*e,this.y=sin(t)*s+cos(t)*e}magnitude(){return Math.sqrt(sqr(this.x)+sqr(this.y)+sqr(this.z))}magnitudeSqr(){return sqr(this.x)+sqr(this.y)+sqr(this.z)}setMagnitude(t){let s=t/Math.sqrt(sqr(this.x)+sqr(this.y)+sqr(this.z));this.x*=s,this.y*=s,this.z*=s}limit(t,s){let e=t,r=null;s&&(e=s,r=t),r&&this.magnitude()<r&&this.setMagnitude(r),this.magnitude()>e&&this.setMagnitude(e)}copy(){return new bVector3(this.x,this.y,this.z)}normalize(){let t=this.magnitude(),s=this.copy();this.x=s.x/t,this.y=s.y/t,this.z=s.z/t}distance(t){if(void 0!==t)return Math.sqrt(sqr(this.x-t.x)+sqr(this.y-t.y)+sqr(this.z-t.z));console.error("You need to pass another bVector3 instance to the bVector3 distance method")}static distance(t,s){if(void 0!==t)return Math.sqrt(sqr(t.x-s.x)+sqr(t.y-s.y)+sqr(t.z-s.z));console.error("bVector3 distance method expects two instances of bVector2")}lerp(t,s){if(void 0===t||void 0===s)return console.error("Invalid arguments for the bVector3 lerp method"),null;this.x=(1-s)*this.x+s*t.x,this.y=(1-s)*this.y+s*t.y,this.z=(1-s)*this.z+s*t.z}static lerp(t,s,e){if(void 0===t||void 0===s||void 0===e)return console.error("Invalid arguments for the bVector3 lerp method"),null;{let r=t.copy();return r.x=(1-e)*r.x+e*s.x,r.y=(1-e)*r.y+e*s.y,r.z=(1-e)*r.z+e*s.z,r}}clamp(t,s,e,r,i,o){this.x>=s?this.x=s:this.x<=t&&(this.x=t),this.y>=r?this.y=r:this.y<=e&&(this.y=e),this.z>=o?this.z=o:this.z<=i&&(this.z=i)}static fromVector3(t){return new bVector3(t.x,t.y,t.z)}toVector3(){return{x:this.x,y:this.y,z:this.z}}stringify(){return`x: ${this.x}, y: ${this.y}, z: ${this.z}`}static fromAngles(t,s){let e=Math.cos(t)*Math.cos(s),r=Math.sin(t)*Math.cos(s),i=Math.sin(s);return new bVector3(e,i,r)}static random(){let t=Math.random(),s=Math.random(),e=Math.random();return new bVector3(t,e,s)}angleOffset(t){return[180*Math.atan2(t.y*this.x-t.x*this.y,t.x*this.x+t.y*this.y)/Math.PI,180*Math.atan2(t.z*this.x-t.x*this.z,t.x*this.x+t.z*this.z)/Math.PI]}static angleOffset(t,s){return[180*Math.atan2(s.y*t.x-s.x*t.y,s.x*t.x+s.y*t.y)/Math.PI,180*Math.atan2(s.z*t.x-s.x*t.z,s.x*t.x+s.z*t.z)/Math.PI]}crossProduct(t){let s=this.y*t.z-this.z*t.y,e=this.z*t.x-this.x*t.z,r=this.x*t.y-this.y*t.x;return new bVector3(s,e,r)}static crossProduct(t,s){if(void 0===t||void 0===s)return console.error("No valid argument provided to the bVector3 crossProduct method"),null;let e=t.y*s.z-t.z*s.y,r=t.z*s.x-t.x*s.z,i=t.x*s.y-t.y*s.x;return new bVector3(e,r,i)}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dotProduct(t,s){return void 0===t||void 0===s?(console.error("No valid argument provided to the bVector3 dotProduct method"),null):t.x*s.x+t.y*s.y+t.z*s.z}}